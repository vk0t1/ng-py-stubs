from typing import Any, Iterable, Iterator

import geopandas
import pandas
import pyarrow
from _typeshed import Incomplete
from google.api_core.page_iterator import HTTPIterator as HTTPIterator
from google.cloud import bigquery_storage as bigquery_storage
from google.cloud.bigquery import external_config as external_config
from google.cloud.bigquery import schema as _schema
from google.cloud.bigquery._tqdm_helpers import get_progress_bar as get_progress_bar
from google.cloud.bigquery.dataset import DatasetReference as DatasetReference
from google.cloud.bigquery.encryption_configuration import EncryptionConfiguration as EncryptionConfiguration
from google.cloud.bigquery.enums import DefaultPandasDTypes as DefaultPandasDTypes
from google.cloud.bigquery.external_config import ExternalConfig as ExternalConfig

ALMOST_COMPLETELY_CACHED_RATIO: float

class _TableBase:
    def __init__(self) -> None: ...
    @property
    def project(self) -> str: ...
    @property
    def dataset_id(self) -> str: ...
    @property
    def table_id(self) -> str: ...
    @property
    def path(self) -> str: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class TableReference(_TableBase):
    def __init__(self, dataset_ref: DatasetReference, table_id: str) -> None: ...
    @classmethod
    def from_string(cls, table_id: str, default_project: str | None = None) -> TableReference: ...
    @classmethod
    def from_api_repr(cls, resource: dict) -> TableReference: ...
    def to_api_repr(self) -> dict: ...
    def to_bqstorage(self) -> str: ...

class Table(_TableBase):
    def __init__(self, table_ref, schema: Incomplete | None = None) -> None: ...
    reference: Incomplete
    @property
    def require_partition_filter(self): ...
    @require_partition_filter.setter
    def require_partition_filter(self, value) -> None: ...
    @property
    def schema(self): ...
    @schema.setter
    def schema(self, value) -> None: ...
    @property
    def labels(self): ...
    @labels.setter
    def labels(self, value) -> None: ...
    @property
    def encryption_configuration(self): ...
    @encryption_configuration.setter
    def encryption_configuration(self, value) -> None: ...
    @property
    def created(self): ...
    @property
    def etag(self): ...
    @property
    def modified(self): ...
    @property
    def num_bytes(self): ...
    @property
    def num_rows(self): ...
    @property
    def self_link(self): ...
    @property
    def full_table_id(self): ...
    @property
    def table_type(self): ...
    @property
    def range_partitioning(self): ...
    @range_partitioning.setter
    def range_partitioning(self, value) -> None: ...
    @property
    def time_partitioning(self): ...
    @time_partitioning.setter
    def time_partitioning(self, value) -> None: ...
    @property
    def partitioning_type(self): ...
    @partitioning_type.setter
    def partitioning_type(self, value) -> None: ...
    @property
    def partition_expiration(self): ...
    @partition_expiration.setter
    def partition_expiration(self, value) -> None: ...
    @property
    def clustering_fields(self): ...
    @clustering_fields.setter
    def clustering_fields(self, value) -> None: ...
    @property
    def description(self): ...
    @description.setter
    def description(self, value) -> None: ...
    @property
    def expires(self): ...
    @expires.setter
    def expires(self, value) -> None: ...
    @property
    def friendly_name(self): ...
    @friendly_name.setter
    def friendly_name(self, value) -> None: ...
    @property
    def location(self): ...
    @property
    def view_query(self): ...
    @view_query.setter
    def view_query(self, value) -> None: ...
    @view_query.deleter
    def view_query(self) -> None: ...
    view_use_legacy_sql: Incomplete
    @view_use_legacy_sql.setter
    def view_use_legacy_sql(self, value) -> None: ...
    @property
    def mview_query(self): ...
    @mview_query.setter
    def mview_query(self, value) -> None: ...
    @mview_query.deleter
    def mview_query(self) -> None: ...
    @property
    def mview_last_refresh_time(self): ...
    @property
    def mview_enable_refresh(self): ...
    @mview_enable_refresh.setter
    def mview_enable_refresh(self, value): ...
    @property
    def mview_refresh_interval(self): ...
    @mview_refresh_interval.setter
    def mview_refresh_interval(self, value) -> None: ...
    @property
    def mview_allow_non_incremental_definition(self): ...
    @mview_allow_non_incremental_definition.setter
    def mview_allow_non_incremental_definition(self, value) -> None: ...
    @property
    def streaming_buffer(self): ...
    @property
    def external_data_configuration(self): ...
    @external_data_configuration.setter
    def external_data_configuration(self, value) -> None: ...
    @property
    def snapshot_definition(self) -> SnapshotDefinition | None: ...
    @property
    def clone_definition(self) -> CloneDefinition | None: ...
    @property
    def table_constraints(self) -> TableConstraints | None: ...
    @table_constraints.setter
    def table_constraints(self, value) -> None: ...
    @property
    def resource_tags(self): ...
    @resource_tags.setter
    def resource_tags(self, value) -> None: ...
    @property
    def external_catalog_table_options(self) -> external_config.ExternalCatalogTableOptions | None: ...
    @external_catalog_table_options.setter
    def external_catalog_table_options(self, value: external_config.ExternalCatalogTableOptions | dict | None): ...
    @property
    def foreign_type_info(self) -> _schema.ForeignTypeInfo | None: ...
    @foreign_type_info.setter
    def foreign_type_info(self, value: _schema.ForeignTypeInfo | dict | None): ...
    @classmethod
    def from_string(cls, full_table_id: str) -> Table: ...
    @classmethod
    def from_api_repr(cls, resource: dict) -> Table: ...
    def to_api_repr(self) -> dict: ...
    def to_bqstorage(self) -> str: ...
    @property
    def max_staleness(self): ...
    @max_staleness.setter
    def max_staleness(self, value) -> None: ...

class TableListItem(_TableBase):
    def __init__(self, resource) -> None: ...
    @property
    def created(self): ...
    @property
    def expires(self): ...
    reference: Incomplete
    @property
    def labels(self): ...
    @property
    def full_table_id(self): ...
    @property
    def table_type(self): ...
    @property
    def time_partitioning(self): ...
    @property
    def partitioning_type(self): ...
    @property
    def partition_expiration(self): ...
    @property
    def friendly_name(self): ...
    view_use_legacy_sql: Incomplete
    @property
    def clustering_fields(self): ...
    @classmethod
    def from_string(cls, full_table_id: str) -> TableListItem: ...
    def to_bqstorage(self) -> str: ...
    def to_api_repr(self) -> dict: ...

class StreamingBuffer:
    estimated_bytes: Incomplete
    estimated_rows: Incomplete
    oldest_entry_time: Incomplete
    def __init__(self, resource) -> None: ...

class SnapshotDefinition:
    base_table_reference: Incomplete
    snapshot_time: Incomplete
    def __init__(self, resource: dict[str, Any]) -> None: ...

class CloneDefinition:
    base_table_reference: Incomplete
    clone_time: Incomplete
    def __init__(self, resource: dict[str, Any]) -> None: ...

class Row:
    def __init__(self, values, field_to_index) -> None: ...
    def values(self): ...
    def keys(self) -> Iterable[str]: ...
    def items(self) -> Iterable[tuple[str, Any]]: ...
    def get(self, key: str, default: Any = None) -> Any: ...
    def __getattr__(self, name): ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: str) -> Any: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

class _NoopProgressBarQueue:
    def put_nowait(self, item) -> None: ...

class RowIterator(HTTPIterator):
    def __init__(
        self,
        client,
        api_request,
        path,
        schema,
        page_token: Incomplete | None = None,
        max_results: Incomplete | None = None,
        page_size: Incomplete | None = None,
        extra_params: Incomplete | None = None,
        table: Incomplete | None = None,
        selected_fields: Incomplete | None = None,
        total_rows: Incomplete | None = None,
        first_page_response: Incomplete | None = None,
        location: str | None = None,
        job_id: str | None = None,
        query_id: str | None = None,
        project: str | None = None,
        num_dml_affected_rows: int | None = None,
        query: str | None = None,
        total_bytes_processed: int | None = None,
    ) -> None: ...
    @property
    def job_id(self) -> str | None: ...
    @property
    def location(self) -> str | None: ...
    @property
    def num_dml_affected_rows(self) -> int | None: ...
    @property
    def project(self) -> str | None: ...
    @property
    def query_id(self) -> str | None: ...
    @property
    def query(self) -> str | None: ...
    @property
    def total_bytes_processed(self) -> int | None: ...
    @property
    def schema(self): ...
    @property
    def total_rows(self) -> int: ...
    def to_arrow_iterable(
        self,
        bqstorage_client: bigquery_storage.BigQueryReadClient | None = None,
        max_queue_size: int = ...,
        max_stream_count: int | None = None,
    ) -> Iterator["pyarrow.RecordBatch"]: ...
    def to_arrow(
        self,
        progress_bar_type: str | None = None,
        bqstorage_client: bigquery_storage.BigQueryReadClient | None = None,
        create_bqstorage_client: bool = True,
    ) -> pyarrow.Table: ...
    def to_dataframe_iterable(
        self,
        bqstorage_client: bigquery_storage.BigQueryReadClient | None = None,
        dtypes: dict[str, Any] | None = None,
        max_queue_size: int = ...,
        max_stream_count: int | None = None,
    ) -> pandas.DataFrame: ...
    def to_dataframe(
        self,
        bqstorage_client: bigquery_storage.BigQueryReadClient | None = None,
        dtypes: dict[str, Any] | None = None,
        progress_bar_type: str | None = None,
        create_bqstorage_client: bool = True,
        geography_as_object: bool = False,
        bool_dtype: Any | None = ...,
        int_dtype: Any | None = ...,
        float_dtype: Any | None = None,
        string_dtype: Any | None = None,
        date_dtype: Any | None = ...,
        datetime_dtype: Any | None = None,
        time_dtype: Any | None = ...,
        timestamp_dtype: Any | None = None,
        range_date_dtype: Any | None = ...,
        range_datetime_dtype: Any | None = ...,
        range_timestamp_dtype: Any | None = ...,
    ) -> pandas.DataFrame: ...
    def to_geodataframe(
        self,
        bqstorage_client: bigquery_storage.BigQueryReadClient | None = None,
        dtypes: dict[str, Any] | None = None,
        progress_bar_type: str | None = None,
        create_bqstorage_client: bool = True,
        geography_column: str | None = None,
    ) -> geopandas.GeoDataFrame: ...
    def __next__(self) -> Row: ...

class _EmptyRowIterator(RowIterator):
    schema: Incomplete
    pages: Incomplete
    total_rows: int
    def __init__(
        self,
        client: Incomplete | None = None,
        api_request: Incomplete | None = None,
        path: Incomplete | None = None,
        schema=(),
        *args,
        **kwargs,
    ) -> None: ...
    def to_arrow(
        self,
        progress_bar_type: Incomplete | None = None,
        bqstorage_client: Incomplete | None = None,
        create_bqstorage_client: bool = True,
    ) -> pyarrow.Table: ...
    def to_dataframe(
        self,
        bqstorage_client: Incomplete | None = None,
        dtypes: Incomplete | None = None,
        progress_bar_type: Incomplete | None = None,
        create_bqstorage_client: bool = True,
        geography_as_object: bool = False,
        bool_dtype: Incomplete | None = None,
        int_dtype: Incomplete | None = None,
        float_dtype: Incomplete | None = None,
        string_dtype: Incomplete | None = None,
        date_dtype: Incomplete | None = None,
        datetime_dtype: Incomplete | None = None,
        time_dtype: Incomplete | None = None,
        timestamp_dtype: Incomplete | None = None,
        range_date_dtype: Incomplete | None = None,
        range_datetime_dtype: Incomplete | None = None,
        range_timestamp_dtype: Incomplete | None = None,
    ) -> pandas.DataFrame: ...
    def to_geodataframe(
        self,
        bqstorage_client: Incomplete | None = None,
        dtypes: Incomplete | None = None,
        progress_bar_type: Incomplete | None = None,
        create_bqstorage_client: bool = True,
        geography_column: str | None = None,
    ) -> pandas.DataFrame: ...
    def to_dataframe_iterable(
        self,
        bqstorage_client: bigquery_storage.BigQueryReadClient | None = None,
        dtypes: dict[str, Any] | None = None,
        max_queue_size: int | None = None,
        max_stream_count: int | None = None,
    ) -> Iterator["pandas.DataFrame"]: ...
    def to_arrow_iterable(
        self,
        bqstorage_client: bigquery_storage.BigQueryReadClient | None = None,
        max_queue_size: int | None = None,
        max_stream_count: int | None = None,
    ) -> Iterator["pyarrow.RecordBatch"]: ...
    def __iter__(self): ...

class PartitionRange:
    def __init__(
        self,
        start: Incomplete | None = None,
        end: Incomplete | None = None,
        interval: Incomplete | None = None,
        _properties: Incomplete | None = None,
    ) -> None: ...
    @property
    def start(self): ...
    @start.setter
    def start(self, value) -> None: ...
    @property
    def end(self): ...
    @end.setter
    def end(self, value) -> None: ...
    @property
    def interval(self): ...
    @interval.setter
    def interval(self, value) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

class RangePartitioning:
    def __init__(
        self, range_: Incomplete | None = None, field: Incomplete | None = None, _properties: Incomplete | None = None
    ) -> None: ...
    @property
    def range_(self): ...
    @range_.setter
    def range_(self, value) -> None: ...
    @property
    def field(self): ...
    @field.setter
    def field(self, value) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

class TimePartitioningType:
    DAY: str
    HOUR: str
    MONTH: str
    YEAR: str

class TimePartitioning:
    def __init__(
        self,
        type_: Incomplete | None = None,
        field: Incomplete | None = None,
        expiration_ms: Incomplete | None = None,
        require_partition_filter: Incomplete | None = None,
    ) -> None: ...
    @property
    def type_(self): ...
    @type_.setter
    def type_(self, value) -> None: ...
    @property
    def field(self): ...
    @field.setter
    def field(self, value) -> None: ...
    @property
    def expiration_ms(self): ...
    @expiration_ms.setter
    def expiration_ms(self, value) -> None: ...
    @property
    def require_partition_filter(self): ...
    @require_partition_filter.setter
    def require_partition_filter(self, value) -> None: ...
    @classmethod
    def from_api_repr(cls, api_repr: dict) -> TimePartitioning: ...
    def to_api_repr(self) -> dict: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

class PrimaryKey:
    columns: Incomplete
    def __init__(self, columns: list[str]) -> None: ...
    def __eq__(self, other): ...

class ColumnReference:
    referencing_column: Incomplete
    referenced_column: Incomplete
    def __init__(self, referencing_column: str, referenced_column: str) -> None: ...
    def __eq__(self, other): ...

class ForeignKey:
    name: Incomplete
    referenced_table: Incomplete
    column_references: Incomplete
    def __init__(
        self, name: str, referenced_table: TableReference, column_references: list[ColumnReference]
    ) -> None: ...
    def __eq__(self, other): ...
    @classmethod
    def from_api_repr(cls, api_repr: dict[str, Any]) -> ForeignKey: ...
    def to_api_repr(self) -> dict[str, Any]: ...

class TableConstraints:
    primary_key: Incomplete
    foreign_keys: Incomplete
    def __init__(self, primary_key: PrimaryKey | None, foreign_keys: list[ForeignKey] | None) -> None: ...
    def __eq__(self, other): ...
    @classmethod
    def from_api_repr(cls, resource: dict[str, Any]) -> TableConstraints: ...
    def to_api_repr(self) -> dict[str, Any]: ...
