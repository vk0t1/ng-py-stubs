# mypy: ignore-errors
import mupdf
import typing
from _typeshed import Incomplete
from collections.abc import Generator

def set_messages(*, text: Incomplete | None = None, fd: Incomplete | None = None, stream: Incomplete | None = None, path: Incomplete | None = None, path_append: Incomplete | None = None, pylogging: Incomplete | None = None, pylogging_logger: Incomplete | None = None, pylogging_level: Incomplete | None = None, pylogging_name: Incomplete | None = None) -> None: ...
def set_log(*, text: Incomplete | None = None, fd: Incomplete | None = None, stream: Incomplete | None = None, path: Incomplete | None = None, path_append: Incomplete | None = None, pylogging: Incomplete | None = None, pylogging_logger: Incomplete | None = None, pylogging_level: Incomplete | None = None, pylogging_name: Incomplete | None = None) -> None: ...
def log(text: str = '', caller: int = 1) -> None: ...
def message(text: str = '') -> None: ...
def exception_info() -> None: ...

INVALID_NAME_CHARS: Incomplete

def get_env_bool(name, default): ...
def get_env_int(name, default): ...

g_exceptions_verbose: Incomplete
g_use_extra: Incomplete

class _Globals:
    no_device_caching: int
    small_glyph_heights: int
    subset_fontnames: int
    skip_quad_corrections: int
    def __init__(self) -> None: ...

mupdf_cppyy: Incomplete
mupdf: Incomplete
pymupdf_version: str
mupdf_version: Incomplete
pymupdf_date: str
pymupdf_version_tuple: Incomplete
mupdf_version_tuple: Incomplete
pymupdf_date2: Incomplete
version: Incomplete
VersionFitz = mupdf_version
VersionBind = pymupdf_version
VersionDate = pymupdf_date
format_g: Incomplete
OptBytes: Incomplete
OptDict = dict | None
OptFloat = float | None
OptInt = int | None
OptSeq = typing.Sequence | None
OptStr = str | None
Point: str
matrix_like: str
point_like: str
quad_like: str
rect_like: str
JM_MEMORY: int

class Annot:
    this: Incomplete
    def __init__(self, annot) -> None: ...
    @property
    def apn_bbox(self): ...
    @property
    def apn_matrix(self): ...
    @property
    def blendmode(self): ...
    @property
    def border(self): ...
    def clean_contents(self, sanitize: int = 1) -> None: ...
    @property
    def colors(self): ...
    def delete_responses(self) -> None: ...
    @property
    def file_info(self): ...
    @property
    def flags(self): ...
    def get_file(self): ...
    def get_oc(self): ...
    parent: Incomplete
    def get_parent(self): ...
    def get_pixmap(self, matrix: Incomplete | None = None, dpi: Incomplete | None = None, colorspace: Incomplete | None = None, alpha: int = 0): ...
    def get_sound(self): ...
    def get_textpage(self, clip: Incomplete | None = None, flags: int = 0): ...
    @property
    def has_popup(self): ...
    @property
    def info(self): ...
    @property
    def irt_xref(self): ...
    @property
    def is_open(self): ...
    @property
    def language(self): ...
    @property
    def line_ends(self): ...
    @property
    def next(self): ...
    @property
    def opacity(self): ...
    @property
    def popup_rect(self): ...
    @property
    def popup_xref(self): ...
    @property
    def rect(self): ...
    @property
    def rect_delta(self): ...
    @property
    def rotation(self): ...
    def set_apn_bbox(self, bbox) -> None: ...
    def set_apn_matrix(self, matrix) -> None: ...
    def set_blendmode(self, blend_mode) -> None: ...
    def set_border(self, border: Incomplete | None = None, width: int = -1, style: Incomplete | None = None, dashes: Incomplete | None = None, clouds: int = -1): ...
    def set_colors(self, colors: Incomplete | None = None, stroke: Incomplete | None = None, fill: Incomplete | None = None) -> None: ...
    def set_flags(self, flags) -> None: ...
    def set_info(self, info: Incomplete | None = None, content: Incomplete | None = None, title: Incomplete | None = None, creationDate: Incomplete | None = None, modDate: Incomplete | None = None, subject: Incomplete | None = None) -> None: ...
    def set_irt_xref(self, xref) -> None: ...
    def set_language(self, language: Incomplete | None = None) -> None: ...
    def set_line_ends(self, start, end) -> None: ...
    def set_name(self, name) -> None: ...
    def set_oc(self, oc: int = 0) -> None: ...
    def set_opacity(self, opacity) -> None: ...
    def set_open(self, is_open) -> None: ...
    def set_popup(self, rect) -> None: ...
    def set_rect(self, rect): ...
    def set_rotation(self, rotate: int = 0) -> None: ...
    @property
    def type(self): ...
    def update(self, blend_mode: OptStr = None, opacity: OptFloat = None, fontsize: float = 0, fontname: OptStr = None, text_color: OptSeq = None, border_color: OptSeq = None, fill_color: OptSeq = None, cross_out: bool = True, rotate: int = -1): ...
    def update_file(self, buffer_: Incomplete | None = None, filename: Incomplete | None = None, ufilename: Incomplete | None = None, desc: Incomplete | None = None) -> None: ...
    @staticmethod
    def update_timing_test(): ...
    @property
    def vertices(self): ...
    @property
    def xref(self): ...

class Archive:
    this: Incomplete
    def __init__(self, *args) -> None: ...
    def add(self, content, path: Incomplete | None = None): ...
    @property
    def entry_list(self): ...
    def has_entry(self, name): ...
    def read_entry(self, name): ...

class Xml:
    def __enter__(self): ...
    def __exit__(self, *args) -> None: ...
    this: Incomplete
    def __init__(self, rhs) -> None: ...
    def add_bullet_list(self): ...
    def add_class(self, text): ...
    def add_code(self, text: Incomplete | None = None): ...
    def add_codeblock(self): ...
    def add_description_list(self): ...
    def add_division(self): ...
    def add_header(self, level: int = 1): ...
    def add_horizontal_line(self): ...
    def add_image(self, name, width: Incomplete | None = None, height: Incomplete | None = None, imgfloat: Incomplete | None = None, align: Incomplete | None = None): ...
    def add_link(self, href, text: Incomplete | None = None): ...
    def add_list_item(self): ...
    def add_number_list(self, start: int = 1, numtype: Incomplete | None = None): ...
    def add_paragraph(self): ...
    def add_span(self): ...
    def add_style(self, text): ...
    def add_subscript(self, text: Incomplete | None = None): ...
    def add_superscript(self, text: Incomplete | None = None): ...
    def add_text(self, text): ...
    def append_child(self, child) -> None: ...
    def append_styled_span(self, style): ...
    def bodytag(self): ...
    def clone(self): ...
    @staticmethod
    def color_text(color): ...
    def create_element(self, tag): ...
    def create_text_node(self, text): ...
    def debug(self) -> None: ...
    def find(self, tag, att, match): ...
    def find_next(self, tag, att, match): ...
    @property
    def first_child(self): ...
    def get_attribute_value(self, key): ...
    def get_attributes(self): ...
    def insert_after(self, node) -> None: ...
    def insert_before(self, node) -> None: ...
    def insert_text(self, text): ...
    @property
    def is_text(self): ...
    @property
    def last_child(self): ...
    @property
    def next(self): ...
    @property
    def parent(self): ...
    @property
    def previous(self): ...
    def remove(self) -> None: ...
    def remove_attribute(self, key) -> None: ...
    @property
    def root(self): ...
    def set_align(self, align): ...
    def set_attribute(self, key, value) -> None: ...
    def set_bgcolor(self, color): ...
    def set_bold(self, val: bool = True): ...
    def set_color(self, color): ...
    def set_columns(self, cols): ...
    def set_font(self, font): ...
    def set_fontsize(self, fontsize): ...
    def set_id(self, unique): ...
    def set_italic(self, val: bool = True): ...
    def set_leading(self, leading): ...
    def set_letter_spacing(self, spacing): ...
    def set_lineheight(self, lineheight): ...
    def set_margins(self, val): ...
    def set_opacity(self, opacity): ...
    def set_pagebreak_after(self): ...
    def set_pagebreak_before(self): ...
    def set_properties(self, align: Incomplete | None = None, bgcolor: Incomplete | None = None, bold: Incomplete | None = None, color: Incomplete | None = None, columns: Incomplete | None = None, font: Incomplete | None = None, fontsize: Incomplete | None = None, indent: Incomplete | None = None, italic: Incomplete | None = None, leading: Incomplete | None = None, letter_spacing: Incomplete | None = None, lineheight: Incomplete | None = None, margins: Incomplete | None = None, pagebreak_after: Incomplete | None = None, pagebreak_before: Incomplete | None = None, word_spacing: Incomplete | None = None, unqid: Incomplete | None = None, cls: Incomplete | None = None): ...
    def set_text_indent(self, indent): ...
    def set_underline(self, val: str = 'underline'): ...
    def set_word_spacing(self, spacing): ...
    def span_bottom(self): ...
    @property
    def tagname(self): ...
    @property
    def text(self): ...
    add_var = add_code
    add_samp = add_code
    add_kbd = add_code

class Colorspace:
    this: Incomplete
    def __init__(self, type_) -> None: ...
    @property
    def n(self): ...
    @property
    def name(self): ...

class DeviceWrapper:
    this: Incomplete
    def __init__(self, *args) -> None: ...

class DisplayList:
    thisown: bool
    def __del__(self) -> None: ...
    this: Incomplete
    def __init__(self, *args) -> None: ...
    def get_pixmap(self, matrix: Incomplete | None = None, colorspace: Incomplete | None = None, alpha: int = 0, clip: Incomplete | None = None): ...
    def get_textpage(self, flags: int = 3): ...
    @property
    def rect(self): ...
    def run(self, dw, m, area) -> None: ...

extra_FzDocument_insert_pdf: Incomplete

class Document:
    def __contains__(self, loc) -> bool: ...
    def __delitem__(self, i) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *args) -> None: ...
    @typing.overload
    def __getitem__(self, i: int = 0) -> Page: ...
    @typing.overload
    def __getitem__(self, i: slice) -> list[Page]: ...
    @typing.overload
    def __getitem__(self, i: tuple[int, int]) -> Page: ...
    is_closed: bool
    is_encrypted: bool
    metadata: Incomplete
    FontInfos: Incomplete
    Graftmaps: Incomplete
    ShownPages: Incomplete
    InsertedImages: Incomplete
    this: Incomplete
    this_is_pdf: bool
    stream: Incomplete
    thisown: bool
    page_count2: Incomplete
    def __init__(self, filename: Incomplete | None = None, stream: Incomplete | None = None, filetype: Incomplete | None = None, rect: Incomplete | None = None, width: int = 0, height: int = 0, fontsize: int = 11) -> None: ...
    def __len__(self) -> int: ...
    @property
    def FormFonts(self): ...
    def add_layer(self, name, creator: Incomplete | None = None, on: Incomplete | None = None) -> None: ...
    def add_ocg(self, name, config: int = -1, on: int = 1, intent: Incomplete | None = None, usage: Incomplete | None = None): ...
    def authenticate(self, password): ...
    def can_save_incrementally(self): ...
    def bake(self, *, annots: bool = True, widgets: bool = True) -> None: ...
    @property
    def chapter_count(self): ...
    def chapter_page_count(self, chapter): ...
    def close(self) -> None: ...
    def convert_to_pdf(self, from_page: int = 0, to_page: int = -1, rotate: int = 0): ...
    def copy_page(self, pno: int, to: int = -1): ...
    def del_xml_metadata(self) -> None: ...
    def delete_page(self, pno: int = -1): ...
    def delete_pages(self, *args, **kw) -> None: ...
    def embfile_add(self, name: str, buffer_: typing.ByteString, filename: OptStr = None, ufilename: OptStr = None, desc: OptStr = None) -> None: ...
    def embfile_count(self) -> int: ...
    def embfile_del(self, item: int | str): ...
    def embfile_get(self, item: int | str) -> bytes: ...
    def embfile_info(self, item: int | str) -> dict: ...
    def embfile_names(self) -> list: ...
    def embfile_upd(self, item: int | str, buffer_: OptBytes = None, filename: OptStr = None, ufilename: OptStr = None, desc: OptStr = None) -> None: ...
    def extract_font(self, xref: int = 0, info_only: int = 0, named: Incomplete | None = None): ...
    def extract_image(self, xref): ...
    def ez_save(self, filename, garbage: int = 3, clean: bool = False, deflate: bool = True, deflate_images: bool = True, deflate_fonts: bool = True, incremental: bool = False, ascii: bool = False, expand: bool = False, linear: bool = False, pretty: bool = False, encryption: int = 1, permissions: int = 4095, owner_pw: Incomplete | None = None, user_pw: Incomplete | None = None, no_new_id: bool = True, preserve_metadata: int = 1, use_objstms: int = 1, compression_effort: int = 0): ...
    def find_bookmark(self, bm): ...
    def fullcopy_page(self, pno, to: int = -1) -> None: ...
    def get_layer(self, config: int = -1): ...
    def get_layers(self): ...
    def get_new_xref(self): ...
    def get_ocgs(self): ...
    def get_outline_xrefs(self): ...
    def get_page_fonts(self, pno: int, full: bool = False) -> list: ...
    def get_page_images(self, pno: int, full: bool = False) -> list: ...
    def get_page_xobjects(self, pno: int) -> list: ...
    def get_sigflags(self): ...
    def get_xml_metadata(self): ...
    def init_doc(self) -> None: ...
    def insert_file(self, infile, from_page: int = -1, to_page: int = -1, start_at: int = -1, rotate: int = -1, links: bool = True, annots: bool = True, show_progress: int = 0, final: int = 1): ...
    def insert_pdf(self, docsrc, *, from_page: int = -1, to_page: int = -1, start_at: int = -1, rotate: int = -1, links: int = 1, annots: int = 1, widgets: int = 1, join_duplicates: int = 0, show_progress: int = 0, final: int = 1, _gmap: Incomplete | None = None) -> None: ...
    @property
    def is_dirty(self): ...
    @property
    def is_fast_webaccess(self): ...
    @property
    def is_form_pdf(self): ...
    @property
    def is_pdf(self): ...
    @property
    def is_reflowable(self): ...
    @property
    def is_repaired(self): ...
    def journal_can_do(self): ...
    def journal_enable(self) -> None: ...
    def journal_is_enabled(self): ...
    def journal_load(self, filename) -> None: ...
    def journal_op_name(self, step): ...
    def journal_position(self): ...
    def journal_redo(self): ...
    def journal_save(self, filename) -> None: ...
    def journal_start_op(self, name: Incomplete | None = None) -> None: ...
    def journal_stop_op(self) -> None: ...
    def journal_undo(self): ...
    @property
    def language(self): ...
    @property
    def last_location(self): ...
    def layer_ui_configs(self): ...
    def layout(self, rect: Incomplete | None = None, width: int = 0, height: int = 0, fontsize: int = 11) -> None: ...
    def load_page(self, page_id): ...
    def location_from_page_number(self, pno): ...
    def make_bookmark(self, loc): ...
    @property
    def markinfo(self) -> dict: ...
    def move_page(self, pno: int, to: int = -1): ...
    @property
    def name(self): ...
    def need_appearances(self, value: Incomplete | None = None): ...
    @property
    def needs_pass(self): ...
    def next_location(self, page_id): ...
    def page_annot_xrefs(self, n): ...
    @property
    def page_count(self): ...
    def page_cropbox(self, pno): ...
    def page_number_from_location(self, page_id): ...
    def page_xref(self, pno): ...
    @property
    def pagelayout(self) -> str: ...
    @property
    def pagemode(self) -> str: ...
    def pages(self, start: OptInt = None, stop: OptInt = None, step: OptInt = None) -> _pages_ret: ...
    def pdf_catalog(self): ...
    def pdf_trailer(self, compressed: int = 0, ascii: int = 0): ...
    @property
    def permissions(self): ...
    def prev_location(self, page_id): ...
    def reload_page(self, page: Page) -> Page: ...
    def resolve_link(self, uri: Incomplete | None = None, chapters: int = 0): ...
    def resolve_names(self): ...
    def save(self, filename, garbage: int = 0, clean: int = 0, deflate: int = 0, deflate_images: int = 0, deflate_fonts: int = 0, incremental: int = 0, ascii: int = 0, expand: int = 0, linear: int = 0, no_new_id: int = 0, appearance: int = 0, pretty: int = 0, encryption: int = 1, permissions: int = 4095, owner_pw: Incomplete | None = None, user_pw: Incomplete | None = None, preserve_metadata: int = 1, use_objstms: int = 0, compression_effort: int = 0) -> None: ...
    def save_snapshot(self, filename) -> None: ...
    def saveIncr(self): ...
    def select(self, pyliste) -> None: ...
    def set_language(self, language: Incomplete | None = None): ...
    def set_layer(self, config, basestate: Incomplete | None = None, on: Incomplete | None = None, off: Incomplete | None = None, rbgroups: Incomplete | None = None, locked: Incomplete | None = None) -> None: ...
    def set_layer_ui_config(self, number, action: int = 0) -> None: ...
    def set_markinfo(self, markinfo: dict) -> bool: ...
    def set_pagelayout(self, pagelayout: str): ...
    def set_pagemode(self, pagemode: str): ...
    def set_xml_metadata(self, metadata) -> None: ...
    def switch_layer(self, config, as_default: int = 0) -> None: ...
    def update_object(self, xref, text, page: Incomplete | None = None) -> None: ...
    def update_stream(self, xref: int = 0, stream: Incomplete | None = None, new: int = 1, compress: int = 1) -> None: ...
    @property
    def version_count(self): ...
    def write(self, garbage: bool = False, clean: bool = False, deflate: bool = False, deflate_images: bool = False, deflate_fonts: bool = False, incremental: bool = False, ascii: bool = False, expand: bool = False, linear: bool = False, no_new_id: bool = False, appearance: bool = False, pretty: bool = False, encryption: int = 1, permissions: int = 4095, owner_pw: Incomplete | None = None, user_pw: Incomplete | None = None, preserve_metadata: int = 1, use_objstms: int = 0, compression_effort: int = 0): ...
    @property
    def xref(self): ...
    def xref_get_key(self, xref, key): ...
    def xref_get_keys(self, xref): ...
    def xref_is_font(self, xref): ...
    def xref_is_image(self, xref): ...
    def xref_is_stream(self, xref: int = 0): ...
    def xref_is_xobject(self, xref): ...
    def xref_length(self): ...
    def xref_object(self, xref, compressed: int = 0, ascii: int = 0): ...
    def xref_set_key(self, xref, key, value) -> None: ...
    def xref_stream(self, xref): ...
    def xref_stream_raw(self, xref): ...
    def xref_xml_metadata(self): ...
    outline: Incomplete
    tobytes = write
    is_stream = xref_is_stream
open = Document

class DocumentWriter:
    def __enter__(self): ...
    def __exit__(self, *args) -> None: ...
    this: Incomplete
    def __init__(self, path, options: str = '') -> None: ...
    def begin_page(self, mediabox): ...
    def close(self) -> None: ...
    def end_page(self) -> None: ...

class Font:
    def __del__(self) -> None: ...
    this: Incomplete
    def __init__(self, fontname: Incomplete | None = None, fontfile: Incomplete | None = None, fontbuffer: Incomplete | None = None, script: int = 0, language: Incomplete | None = None, ordering: int = -1, is_bold: int = 0, is_italic: int = 0, is_serif: int = 0, embed: int = 1) -> None: ...
    @property
    def ascender(self): ...
    @property
    def bbox(self): ...
    @property
    def buffer(self): ...
    def char_lengths(self, text, fontsize: int = 11, language: Incomplete | None = None, script: int = 0, wmode: int = 0, small_caps: int = 0): ...
    @property
    def descender(self): ...
    @property
    def flags(self): ...
    def glyph_advance(self, chr_, language: Incomplete | None = None, script: int = 0, wmode: int = 0, small_caps: int = 0): ...
    def glyph_bbox(self, char, language: Incomplete | None = None, script: int = 0, small_caps: int = 0): ...
    @property
    def glyph_count(self): ...
    def glyph_name_to_unicode(self, name): ...
    def has_glyph(self, chr, language: Incomplete | None = None, script: int = 0, fallback: int = 0, small_caps: int = 0): ...
    @property
    def is_bold(self): ...
    @property
    def is_italic(self): ...
    @property
    def is_monospaced(self): ...
    @property
    def is_serif(self): ...
    @property
    def is_writable(self): ...
    @property
    def name(self): ...
    def text_length(self, text, fontsize: int = 11, language: Incomplete | None = None, script: int = 0, wmode: int = 0, small_caps: int = 0): ...
    def unicode_to_glyph_name(self, ch): ...
    def valid_codepoints(self): ...

class Graftmap:
    thisown: bool
    def __del__(self) -> None: ...
    this: Incomplete
    def __init__(self, doc) -> None: ...

class Link:
    def __del__(self) -> None: ...
    this: Incomplete
    def __init__(self, this) -> None: ...
    @property
    def border(self): ...
    @property
    def colors(self): ...
    @property
    def dest(self): ...
    @property
    def flags(self) -> int: ...
    @property
    def is_external(self): ...
    @property
    def next(self): ...
    @property
    def rect(self): ...
    def set_border(self, border: Incomplete | None = None, width: int = 0, dashes: Incomplete | None = None, style: Incomplete | None = None): ...
    def set_colors(self, colors: Incomplete | None = None, stroke: Incomplete | None = None, fill: Incomplete | None = None) -> None: ...
    def set_flags(self, flags) -> None: ...
    @property
    def uri(self): ...
    page: int

class Matrix:
    def __abs__(self): ...
    def __add__(self, m): ...
    def __bool__(self) -> bool: ...
    def __eq__(self, mat): ...
    def __getitem__(self, i): ...
    a: float
    b: Incomplete
    c: Incomplete
    d: Incomplete
    e: Incomplete
    f: Incomplete
    def __init__(self, *args, a: Incomplete | None = None, b: Incomplete | None = None, c: Incomplete | None = None, d: Incomplete | None = None, e: Incomplete | None = None, f: Incomplete | None = None) -> None: ...
    def __invert__(self): ...
    def __len__(self) -> int: ...
    def __mul__(self, m): ...
    def __neg__(self): ...
    def __nonzero__(self): ...
    def __pos__(self): ...
    def __setitem__(self, i, v) -> None: ...
    def __sub__(self, m): ...
    def __truediv__(self, m): ...
    def concat(self, one, two): ...
    def invert(self, src: Incomplete | None = None): ...
    @property
    def is_rectilinear(self): ...
    def prerotate(self, theta): ...
    def prescale(self, sx, sy): ...
    def preshear(self, h, v): ...
    def pretranslate(self, tx, ty): ...
    __inv__ = __invert__
    __div__ = __truediv__
    norm = __abs__

class IdentityMatrix(Matrix):
    def __hash__(self): ...
    def __init__(self) -> None: ...
    def __setattr__(self, name, value) -> None: ...
    def checkargs(*args) -> None: ...

Identity: Incomplete

class linkDest:
    dest: str
    file_spec: str
    flags: int
    is_map: bool
    is_uri: bool
    kind: Incomplete
    lt: Incomplete
    named: Incomplete
    new_window: str
    page: Incomplete
    rb: Incomplete
    uri: Incomplete
    def __init__(self, obj, rlink, document: Incomplete | None = None) -> None: ...

class Widget:
    border_color: Incomplete
    border_style: str
    border_width: int
    border_dashes: Incomplete
    choice_values: Incomplete
    rb_parent: Incomplete
    field_name: Incomplete
    field_label: Incomplete
    field_value: Incomplete
    field_flags: int
    field_display: int
    field_type: int
    field_type_string: Incomplete
    fill_color: Incomplete
    button_caption: Incomplete
    is_signed: Incomplete
    text_color: Incomplete
    text_font: str
    text_fontsize: int
    text_maxlen: int
    text_format: int
    script: Incomplete
    script_stroke: Incomplete
    script_format: Incomplete
    script_change: Incomplete
    script_calc: Incomplete
    script_blur: Incomplete
    script_focus: Incomplete
    rect: Incomplete
    xref: int
    def __init__(self) -> None: ...
    def button_states(self): ...
    @property
    def next(self): ...
    def on_state(self): ...
    def reset(self) -> None: ...
    def update(self) -> None: ...

class Outline:
    this: Incomplete
    def __init__(self, ol) -> None: ...
    @property
    def dest(self): ...
    def destination(self, document): ...
    @property
    def down(self): ...
    @property
    def is_external(self): ...
    @property
    def is_open(self): ...
    @property
    def next(self): ...
    @property
    def page(self): ...
    @property
    def title(self): ...
    @property
    def uri(self): ...
    @property
    def x(self): ...
    @property
    def y(self): ...

class Page:
    this: Incomplete
    thisown: bool
    last_point: Incomplete
    draw_cont: str
    parent: Incomplete
    number: Incomplete
    def __init__(self, page, document) -> None: ...
    def add_caret_annot(self, point: point_like) -> Annot: ...
    def add_circle_annot(self, rect: rect_like) -> Annot: ...
    def add_file_annot(self, point: point_like, buffer_: typing.ByteString, filename: str, ufilename: OptStr = None, desc: OptStr = None, icon: OptStr = None) -> Annot: ...
    def add_freetext_annot(self, rect: rect_like, text: str, *, fontsize: float = 11, fontname: OptStr = None, text_color: OptSeq = None, fill_color: OptSeq = None, border_color: OptSeq = None, border_width: float = 0, dashes: OptSeq = None, callout: OptSeq = None, line_end: int = ..., opacity: float = 1, align: int = 0, rotate: int = 0, richtext: bool = False, style: Incomplete | None = None) -> Annot: ...
    def add_highlight_annot(self, quads: Incomplete | None = None, start: Incomplete | None = None, stop: Incomplete | None = None, clip: Incomplete | None = None) -> Annot: ...
    def add_ink_annot(self, handwriting: list) -> Annot: ...
    def add_line_annot(self, p1: point_like, p2: point_like) -> Annot: ...
    def add_polygon_annot(self, points: list) -> Annot: ...
    def add_polyline_annot(self, points: list) -> Annot: ...
    def add_rect_annot(self, rect: rect_like) -> Annot: ...
    def add_redact_annot(self, quad, text: OptStr = None, fontname: OptStr = None, fontsize: float = 11, align: int = 0, fill: OptSeq = None, text_color: OptSeq = None, cross_out: bool = True) -> Annot: ...
    def add_squiggly_annot(self, quads: Incomplete | None = None, start: Incomplete | None = None, stop: Incomplete | None = None, clip: Incomplete | None = None) -> Annot: ...
    def add_stamp_annot(self, rect: rect_like, stamp: int = 0) -> Annot: ...
    def add_strikeout_annot(self, quads: Incomplete | None = None, start: Incomplete | None = None, stop: Incomplete | None = None, clip: Incomplete | None = None) -> Annot: ...
    def add_text_annot(self, point: point_like, text: str, icon: str = 'Note') -> Annot: ...
    def add_underline_annot(self, quads: Incomplete | None = None, start: Incomplete | None = None, stop: Incomplete | None = None, clip: Incomplete | None = None) -> Annot: ...
    def add_widget(self, widget: Widget) -> Annot: ...
    def annot_names(self): ...
    def annot_xrefs(self): ...
    def annots(self, types: Incomplete | None = None) -> Generator[Incomplete]: ...
    @property
    def artbox(self): ...
    @property
    def bleedbox(self): ...
    def bound(self): ...
    def clean_contents(self, sanitize: int = 1) -> None: ...
    @property
    def cropbox(self): ...
    @property
    def cropbox_position(self): ...
    def delete_annot(self, annot): ...
    def delete_link(self, linkdict): ...
    @property
    def derotation_matrix(self) -> Matrix: ...
    def extend_textpage(self, tpage, flags: int = 0, matrix: Incomplete | None = None) -> None: ...
    @property
    def first_annot(self): ...
    @property
    def first_link(self): ...
    @property
    def first_widget(self): ...
    def get_bboxlog(self, layers: Incomplete | None = None): ...
    def get_cdrawings(self, extended: Incomplete | None = None, callback: Incomplete | None = None, method: Incomplete | None = None): ...
    def get_contents(self): ...
    def get_displaylist(self, annots: int = 1): ...
    paths: Incomplete
    path_count: int
    group_count: int
    clip_count: int
    fill_count: int
    stroke_count: int
    fillstroke_count: int
    def get_drawings(self, extended: bool = False) -> list: ...
    def remove_rotation(self): ...
    def cluster_drawings(self, clip: Incomplete | None = None, drawings: Incomplete | None = None, x_tolerance: float = 3, y_tolerance: float = 3) -> list: ...
    def get_fonts(self, full: bool = False): ...
    def get_image_bbox(self, name, transform: int = 0): ...
    def get_images(self, full: bool = False): ...
    def get_oc_items(self) -> list: ...
    def get_svg_image(self, matrix: Incomplete | None = None, text_as_path: int = 1): ...
    def get_text(self) -> str: ...
    def get_textbox(page: Page, rect: rect_like, textpage: Incomplete | None = None) -> str: ...
    def get_textpage(self, clip: rect_like = None, flags: int = 0, matrix: Incomplete | None = None) -> TextPage: ...
    def get_texttrace(self): ...
    def get_xobjects(self): ...
    def get_pixmap(self, matrix: Incomplete | None = None, colorspace: Incomplete | None = None, alpha: int = 0, clip: Incomplete | None = None) -> Pixmap: ...
    def insert_font(self, fontname: str = 'helv', fontfile: Incomplete | None = None, fontbuffer: Incomplete | None = None, set_simple: bool = False, wmode: int = 0, encoding: int = 0): ...
    @property
    def is_wrapped(self): ...
    @property
    def language(self): ...
    def links(self, kinds: Incomplete | None = None) -> Generator[Incomplete]: ...
    def load_annot(self, ident: str | int) -> Annot: ...
    def load_links(self): ...
    def load_widget(self, xref): ...
    @property
    def mediabox(self): ...
    @property
    def mediabox_size(self): ...
    def read_contents(self): ...
    def refresh(self) -> None: ...
    @property
    def rotation(self): ...
    @property
    def rotation_matrix(self) -> Matrix: ...
    def run(self, dw, m) -> None: ...
    def set_artbox(self, rect): ...
    def set_bleedbox(self, rect): ...
    def set_contents(self, xref) -> None: ...
    def set_cropbox(self, rect): ...
    def set_language(self, language: Incomplete | None = None) -> None: ...
    def set_mediabox(self, rect) -> None: ...
    def set_rotation(self, rotation) -> None: ...
    def set_trimbox(self, rect): ...
    @property
    def transformation_matrix(self): ...
    @property
    def trimbox(self): ...
    def widgets(self, types: Incomplete | None = None) -> Generator[Incomplete]: ...
    def wrap_contents(self) -> None: ...
    @property
    def xref(self): ...
    rect: Incomplete

class Pixmap:
    this: Incomplete
    def __init__(self, *args) -> None: ...
    def __len__(self) -> int: ...
    @property
    def alpha(self): ...
    def clear_with(self, value: Incomplete | None = None, bbox: Incomplete | None = None) -> None: ...
    def color_count(self, colors: int = 0, clip: Incomplete | None = None): ...
    def color_topusage(self, clip: Incomplete | None = None): ...
    @property
    def colorspace(self): ...
    def copy(self, src, bbox) -> None: ...
    @property
    def digest(self): ...
    def gamma_with(self, gamma) -> None: ...
    @property
    def h(self): ...
    def invert_irect(self, bbox: Incomplete | None = None): ...
    @property
    def irect(self): ...
    @property
    def is_monochrome(self): ...
    @property
    def is_unicolor(self): ...
    @property
    def n(self): ...
    def pdfocr_save(self, filename, compress: int = 1, language: Incomplete | None = None, tessdata: Incomplete | None = None) -> None: ...
    def pdfocr_tobytes(self, compress: bool = True, language: str = 'eng', tessdata: Incomplete | None = None): ...
    def pil_image(self): ...
    def pil_save(self, *args, **kwargs) -> None: ...
    def pil_tobytes(self, *args, **kwargs): ...
    def pixel(self, x, y): ...
    @property
    def samples(self) -> bytes: ...
    @property
    def samples_mv(self): ...
    @property
    def samples_ptr(self): ...
    def save(self, filename, output: Incomplete | None = None, jpg_quality: int = 95): ...
    def set_alpha(self, alphavalues: Incomplete | None = None, premultiply: int = 1, opaque: Incomplete | None = None, matte: Incomplete | None = None): ...
    def tobytes(self, output: str = 'png', jpg_quality: int = 95): ...
    def set_dpi(self, xres, yres) -> None: ...
    def set_origin(self, x, y) -> None: ...
    def set_pixel(self, x, y, color): ...
    def set_rect(self, bbox, color): ...
    def shrink(self, factor) -> None: ...
    @property
    def size(self): ...
    @property
    def stride(self): ...
    def tint_with(self, black, white): ...
    @property
    def w(self): ...
    def warp(self, quad, width, height): ...
    @property
    def x(self): ...
    @property
    def xres(self): ...
    @property
    def y(self): ...
    @property
    def yres(self): ...
    width = w
    height = h
    def __del__(self) -> None: ...

class Point:
    def __abs__(self): ...
    def __add__(self, p): ...
    def __bool__(self) -> bool: ...
    def __eq__(self, p): ...
    def __getitem__(self, i): ...
    def __hash__(self): ...
    x: float
    y: float
    def __init__(self, *args, x: Incomplete | None = None, y: Incomplete | None = None) -> None: ...
    def __len__(self) -> int: ...
    def __mul__(self, m): ...
    def __neg__(self): ...
    def __nonzero__(self): ...
    def __pos__(self): ...
    def __setitem__(self, i, v) -> None: ...
    def __sub__(self, p): ...
    def __truediv__(self, m): ...
    @property
    def abs_unit(self): ...
    def distance_to(self, *args): ...
    def transform(self, m): ...
    @property
    def unit(self): ...
    __div__ = __truediv__
    norm = __abs__

class Quad:
    def __abs__(self): ...
    def __add__(self, q): ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x) -> bool: ...
    def __eq__(self, quad): ...
    def __getitem__(self, i): ...
    def __hash__(self): ...
    ul: Incomplete
    this: Incomplete
    ur: Incomplete
    ll: Incomplete
    lr: Incomplete
    def __init__(self, *args, ul: Incomplete | None = None, ur: Incomplete | None = None, ll: Incomplete | None = None, lr: Incomplete | None = None) -> None: ...
    def __len__(self) -> int: ...
    def __mul__(self, m): ...
    def __neg__(self): ...
    def __nonzero__(self): ...
    def __pos__(self): ...
    def __setitem__(self, i, v) -> None: ...
    def __sub__(self, q): ...
    def __truediv__(self, m): ...
    @property
    def is_convex(self): ...
    @property
    def is_empty(self): ...
    @property
    def is_infinite(self): ...
    @property
    def is_rectangular(self): ...
    def morph(self, p, m): ...
    @property
    def rect(self): ...
    def transform(self, m): ...
    __div__ = __truediv__
    width: Incomplete
    height: Incomplete

class Rect:
    def __abs__(self): ...
    def __add__(self, p): ...
    def __and__(self, x): ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x) -> bool: ...
    def __eq__(self, rect): ...
    def __getitem__(self, i): ...
    def __hash__(self): ...
    x0: Incomplete
    y0: Incomplete
    x1: Incomplete
    y1: Incomplete
    def __init__(self, *args, p0: Incomplete | None = None, p1: Incomplete | None = None, x0: Incomplete | None = None, y0: Incomplete | None = None, x1: Incomplete | None = None, y1: Incomplete | None = None) -> None: ...
    def __len__(self) -> int: ...
    def __mul__(self, m): ...
    def __neg__(self): ...
    def __nonzero__(self): ...
    def __or__(self, x): ...
    def __pos__(self): ...
    def __setitem__(self, i, v) -> None: ...
    def __sub__(self, p): ...
    def __truediv__(self, m): ...
    @property
    def bottom_left(self): ...
    @property
    def bottom_right(self): ...
    def contains(self, x): ...
    @property
    def height(self): ...
    def include_point(self, p): ...
    def include_rect(self, r): ...
    def intersect(self, r): ...
    def intersects(self, x): ...
    @property
    def is_empty(self): ...
    @property
    def is_infinite(self): ...
    @property
    def is_valid(self): ...
    def morph(self, p, m): ...
    def norm(self): ...
    def normalize(self): ...
    @property
    def quad(self): ...
    def round(self): ...
    @property
    def top_left(self): ...
    @property
    def top_right(self): ...
    def torect(self, r): ...
    def transform(self, m): ...
    @property
    def width(self): ...
    __div__ = __truediv__
    bl = bottom_left
    br = bottom_right
    irect: Incomplete
    tl = top_left
    tr = top_right

class Shape:
    page: Incomplete
    doc: Incomplete
    height: Incomplete
    width: Incomplete
    x: Incomplete
    y: Incomplete
    pctm: Incomplete
    ipctm: Incomplete
    draw_cont: str
    text_cont: str
    totalcont: str
    last_point: Incomplete
    rect: Incomplete
    def __init__(self, page: Page) -> None: ...
    def commit(self, overlay: bool = True) -> None: ...
    def draw_bezier(self, p1: point_like, p2: point_like, p3: point_like, p4: point_like): ...
    def draw_circle(self, center: point_like, radius: float): ...
    def draw_curve(self, p1: point_like, p2: point_like, p3: point_like): ...
    def draw_line(self, p1: point_like, p2: point_like): ...
    def draw_oval(self, tetra: quad_like | rect_like): ...
    def draw_polyline(self, points: list): ...
    def draw_quad(self, quad: quad_like): ...
    def draw_rect(self, rect: rect_like): ...
    def draw_sector(self, center: point_like, point: point_like, beta: float, fullSector: bool = True): ...
    def draw_squiggle(self, p1: point_like, p2: point_like, breadth: int = 2): ...
    def draw_zigzag(self, p1: point_like, p2: point_like, breadth: float = 2): ...
    def finish(self, width: float = 1, color: OptSeq = (0,), fill: OptSeq = None, lineCap: int = 0, lineJoin: int = 0, dashes: OptStr = None, even_odd: bool = False, morph: OptSeq = None, closePath: bool = True, fill_opacity: float = 1, stroke_opacity: float = 1, oc: int = 0) -> None: ...
    @staticmethod
    def horizontal_angle(C, P): ...
    def insert_text(self, point: point_like, buffer_: str | list, fontsize: float = 11, lineheight: OptFloat = None, fontname: str = 'helv', fontfile: OptStr = None, set_simple: bool = 0, encoding: int = 0, color: OptSeq = None, fill: OptSeq = None, render_mode: int = 0, border_width: float = 1, rotate: int = 0, morph: OptSeq = None, stroke_opacity: float = 1, fill_opacity: float = 1, oc: int = 0) -> int: ...
    def update_rect(self, x) -> None: ...

class Story:
    this: Incomplete
    def __init__(self, html: str = '', user_css: Incomplete | None = None, em: int = 12, archive: Incomplete | None = None) -> None: ...
    def add_header_ids(self) -> None: ...
    @staticmethod
    def add_pdf_links(document_or_stream, positions): ...
    @property
    def body(self): ...
    def document(self): ...
    def draw(self, device, matrix: Incomplete | None = None) -> None: ...
    def element_positions(self, function, args: Incomplete | None = None) -> None: ...
    def place(self, where): ...
    def reset(self) -> None: ...
    def write(self, writer, rectfn, positionfn: Incomplete | None = None, pagefn: Incomplete | None = None) -> None: ...
    @staticmethod
    def write_stabilized(writer, contentfn, rectfn, user_css: Incomplete | None = None, em: int = 12, positionfn: Incomplete | None = None, pagefn: Incomplete | None = None, archive: Incomplete | None = None, add_header_ids: bool = True) -> None: ...
    @staticmethod
    def write_stabilized_with_links(contentfn, rectfn, user_css: Incomplete | None = None, em: int = 12, positionfn: Incomplete | None = None, pagefn: Incomplete | None = None, archive: Incomplete | None = None, add_header_ids: bool = True): ...
    def write_with_links(self, rectfn, positionfn: Incomplete | None = None, pagefn: Incomplete | None = None): ...
    class FitResult:
        big_enough: Incomplete
        filled: Incomplete
        more: Incomplete
        numcalls: Incomplete
        parameter: Incomplete
        rect: Incomplete
        def __init__(self, big_enough: Incomplete | None = None, filled: Incomplete | None = None, more: Incomplete | None = None, numcalls: Incomplete | None = None, parameter: Incomplete | None = None, rect: Incomplete | None = None) -> None: ...
    pmin: Incomplete
    pmax: Incomplete
    pmin_result: Incomplete
    pmax_result: Incomplete
    result: Incomplete
    numcalls: int
    pmin0: Incomplete
    pmax0: Incomplete
    def fit(self, fn, pmin: Incomplete | None = None, pmax: Incomplete | None = None, delta: float = 0.001, verbose: bool = False): ...
    def fit_scale(self, rect, scale_min: int = 0, scale_max: Incomplete | None = None, delta: float = 0.001, verbose: bool = False): ...
    def fit_height(self, width, height_min: int = 0, height_max: Incomplete | None = None, origin=(0, 0), delta: float = 0.001, verbose: bool = False): ...
    def fit_width(self, height, width_min: int = 0, width_max: Incomplete | None = None, origin=(0, 0), delta: float = 0.001, verbose: bool = False): ...

class TextPage:
    this: Incomplete
    thisown: bool
    parent: Incomplete
    def __init__(self, *args) -> None: ...
    def extractBLOCKS(self): ...
    def extractDICT(self, cb: Incomplete | None = None, sort: bool = False) -> dict: ...
    def extractHTML(self) -> str: ...
    def extractIMGINFO(self, hashes: int = 0): ...
    def extractJSON(self, cb: Incomplete | None = None, sort: bool = False) -> str: ...
    def extractRAWDICT(self, cb: Incomplete | None = None, sort: bool = False) -> dict: ...
    def extractRAWJSON(self, cb: Incomplete | None = None, sort: bool = False) -> str: ...
    def extractSelection(self, pointa, pointb): ...
    def extractText(self, sort: bool = False) -> str: ...
    def extractTextbox(self, rect): ...
    def extractWORDS(self, delimiters: Incomplete | None = None): ...
    def extractXHTML(self) -> str: ...
    def extractXML(self) -> str: ...
    def poolsize(self): ...
    @property
    def rect(self): ...
    def search(self, needle, hit_max: int = 0, quads: int = 1): ...
    extractTEXT = extractText

class TextWriter:
    this: Incomplete
    opacity: Incomplete
    color: Incomplete
    rect: Incomplete
    ctm: Incomplete
    ictm: Incomplete
    last_point: Incomplete
    text_rect: Incomplete
    used_fonts: Incomplete
    thisown: bool
    def __init__(self, page_rect, opacity: int = 1, color: Incomplete | None = None) -> None: ...
    def append(self, pos, text, font: Incomplete | None = None, fontsize: int = 11, language: Incomplete | None = None, right_to_left: int = 0, small_caps: int = 0): ...
    def appendv(self, pos, text, font: Incomplete | None = None, fontsize: int = 11, language: Incomplete | None = None, small_caps: bool = False): ...
    def clean_rtl(self, text): ...
    def write_text(self, page, color: Incomplete | None = None, opacity: int = -1, overlay: int = 1, morph: Incomplete | None = None, matrix: Incomplete | None = None, render_mode: int = 0, oc: int = 0): ...

class IRect:
    def __add__(self, p): ...
    def __and__(self, x): ...
    def __contains__(self, x) -> bool: ...
    def __eq__(self, r): ...
    def __getitem__(self, i): ...
    def __hash__(self): ...
    def __init__(self, *args, p0: Incomplete | None = None, p1: Incomplete | None = None, x0: Incomplete | None = None, y0: Incomplete | None = None, x1: Incomplete | None = None, y1: Incomplete | None = None) -> None: ...
    def __len__(self) -> int: ...
    def __mul__(self, m): ...
    def __neg__(self): ...
    def __or__(self, x): ...
    def __pos__(self): ...
    x0: Incomplete
    y0: Incomplete
    x1: Incomplete
    y1: Incomplete
    def __setitem__(self, i, v) -> None: ...
    def __sub__(self, p): ...
    def __truediv__(self, m): ...
    @property
    def bottom_left(self): ...
    @property
    def bottom_right(self): ...
    @property
    def height(self): ...
    def include_point(self, p): ...
    def include_rect(self, r): ...
    def intersect(self, r): ...
    def intersects(self, x): ...
    @property
    def is_empty(self): ...
    @property
    def is_infinite(self): ...
    @property
    def is_valid(self): ...
    def morph(self, p, m): ...
    def norm(self): ...
    def normalize(self): ...
    @property
    def quad(self): ...
    @property
    def rect(self): ...
    @property
    def top_left(self): ...
    @property
    def top_right(self): ...
    def torect(self, r): ...
    def transform(self, m): ...
    @property
    def width(self): ...
    br = bottom_right
    bl = bottom_left
    tl = top_left
    tr = top_right

PDF_SIGNATURE_DEFAULT_APPEARANCE: Incomplete
AnyType: Incomplete
Base14_fontnames: Incomplete
Base14_fontdict: Incomplete
EPSILON: float
FLT_EPSILON: float
FZ_MIN_INF_RECT: int
FZ_MAX_INF_RECT: int
JM_annot_id_stem: str
JM_mupdf_warnings_store: Incomplete
JM_mupdf_show_errors: int
JM_mupdf_show_warnings: int
PDF_OC_ON: int
PDF_OC_TOGGLE: int
PDF_OC_OFF: int
LINK_NONE: int
LINK_GOTO: int
LINK_URI: int
LINK_LAUNCH: int
LINK_NAMED: int
LINK_GOTOR: int
LINK_FLAG_L_VALID: int
LINK_FLAG_T_VALID: int
LINK_FLAG_R_VALID: int
LINK_FLAG_B_VALID: int
LINK_FLAG_FIT_H: int
LINK_FLAG_FIT_V: int
LINK_FLAG_R_IS_ZOOM: int
SigFlag_SignaturesExist: int
SigFlag_AppendOnly: int
STAMP_Approved: int
STAMP_AsIs: int
STAMP_Confidential: int
STAMP_Departmental: int
STAMP_Experimental: int
STAMP_Expired: int
STAMP_Final: int
STAMP_ForComment: int
STAMP_ForPublicRelease: int
STAMP_NotApproved: int
STAMP_NotForPublicRelease: int
STAMP_Sold: int
STAMP_TopSecret: int
STAMP_Draft: int
TEXT_ALIGN_LEFT: int
TEXT_ALIGN_CENTER: int
TEXT_ALIGN_RIGHT: int
TEXT_ALIGN_JUSTIFY: int
TEXT_FONT_SUPERSCRIPT: int
TEXT_FONT_ITALIC: int
TEXT_FONT_SERIFED: int
TEXT_FONT_MONOSPACED: int
TEXT_FONT_BOLD: int
TEXT_OUTPUT_TEXT: int
TEXT_OUTPUT_HTML: int
TEXT_OUTPUT_JSON: int
TEXT_OUTPUT_XML: int
TEXT_OUTPUT_XHTML: int
TEXT_PRESERVE_LIGATURES: Incomplete
TEXT_PRESERVE_WHITESPACE: Incomplete
TEXT_PRESERVE_IMAGES: Incomplete
TEXT_INHIBIT_SPACES: Incomplete
TEXT_DEHYPHENATE: Incomplete
TEXT_PRESERVE_SPANS: Incomplete
TEXT_MEDIABOX_CLIP: Incomplete
TEXT_CID_FOR_UNKNOWN_UNICODE: Incomplete
TEXT_COLLECT_STRUCTURE: Incomplete
TEXT_ACCURATE_BBOXES: Incomplete
TEXT_COLLECT_VECTORS: Incomplete
TEXT_IGNORE_ACTUALTEXT: Incomplete
TEXT_STEXT_SEGMENT: Incomplete
TEXTFLAGS_WORDS: Incomplete
TEXTFLAGS_BLOCKS: Incomplete
TEXTFLAGS_DICT: Incomplete
TEXTFLAGS_RAWDICT = TEXTFLAGS_DICT
TEXTFLAGS_SEARCH: Incomplete
TEXTFLAGS_HTML: Incomplete
TEXTFLAGS_XHTML: Incomplete
TEXTFLAGS_XML: Incomplete
TEXTFLAGS_TEXT: Incomplete
TEXT_ENCODING_LATIN: int
TEXT_ENCODING_GREEK: int
TEXT_ENCODING_CYRILLIC: int
TOOLS_JM_UNIQUE_ID: int
CS_RGB: int
CS_GRAY: int
CS_CMYK: int
PDF_BM_Color: str
PDF_BM_ColorBurn: str
PDF_BM_ColorDodge: str
PDF_BM_Darken: str
PDF_BM_Difference: str
PDF_BM_Exclusion: str
PDF_BM_HardLight: str
PDF_BM_Hue: str
PDF_BM_Lighten: str
PDF_BM_Luminosity: str
PDF_BM_Multiply: str
PDF_BM_Normal: str
PDF_BM_Overlay: str
PDF_BM_Saturation: str
PDF_BM_Screen: str
PDF_BM_SoftLight: str
annot_skel: Incomplete

class FileDataError(RuntimeError): ...
class FileNotFoundError(RuntimeError): ...
class EmptyFileError(FileDataError): ...

csRGB: Incomplete
csGRAY: Incomplete
csCMYK: Incomplete
dictkey_align: str
dictkey_asc: str
dictkey_bidi: str
dictkey_bbox: str
dictkey_blocks: str
dictkey_bpc: str
dictkey_c: str
dictkey_chars: str
dictkey_color: str
dictkey_colorspace: str
dictkey_content: str
dictkey_creationDate: str
dictkey_cs_name: str
dictkey_da: str
dictkey_dashes: str
dictkey_descr: str
dictkey_desc: str
dictkey_dir: str
dictkey_effect: str
dictkey_ext: str
dictkey_filename: str
dictkey_fill: str
dictkey_flags: str
dictkey_char_flags: str
dictkey_font: str
dictkey_glyph: str
dictkey_height: str
dictkey_id: str
dictkey_image: str
dictkey_items: str
dictkey_length: str
dictkey_lines: str
dictkey_matrix: str
dictkey_modDate: str
dictkey_name: str
dictkey_number: str
dictkey_origin: str
dictkey_rect: str
dictkey_size: str
dictkey_smask: str
dictkey_spans: str
dictkey_stroke: str
dictkey_style: str
dictkey_subject: str
dictkey_text: str
dictkey_title: str
dictkey_type: str
dictkey_ufilename: str
dictkey_width: str
dictkey_wmode: str
dictkey_xref: str
dictkey_xres: str
dictkey_yres: str
fitz_fontdescriptors: Incomplete
symbol_glyphs: Incomplete
zapf_glyphs: Incomplete

def ASSERT_PDF(cond) -> None: ...
def EMPTY_IRECT(): ...
def EMPTY_QUAD(): ...
def EMPTY_RECT(): ...
def ENSURE_OPERATION(pdf) -> None: ...
def INFINITE_IRECT(): ...
def INFINITE_QUAD(): ...
def INFINITE_RECT(): ...
def JM_BinFromBuffer(buffer_): ...
def JM_EscapeStrFromStr(c): ...
def JM_BufferFromBytes(stream): ...
def JM_FLOAT_ITEM(obj, idx): ...
def JM_INT_ITEM(obj, idx): ...
def JM_pixmap_from_page(doc, page, ctm, cs, alpha, annots, clip): ...
def JM_StrAsChar(x): ...
def JM_TUPLE(o: typing.Sequence) -> tuple: ...
def JM_TUPLE3(o: typing.Sequence) -> tuple: ...
def JM_UnicodeFromStr(s): ...
def JM_add_annot_id(annot, stem) -> None: ...
def JM_add_oc_object(pdf, ref, xref) -> None: ...
def JM_annot_border(annot_obj): ...
def JM_annot_colors(annot_obj): ...
def JM_annot_set_border(border, doc, annot_obj) -> None: ...
def make_escape(ch): ...
def JM_append_rune(buff, ch) -> None: ...
def JM_append_word(lines, buff, wbbox, block_n, line_n, word_n): ...
def JM_add_layer_config(pdf, name, creator, ON) -> None: ...
def JM_char_bbox(line, ch): ...
def JM_char_font_flags(font, line, ch): ...
def JM_char_quad(line, ch): ...
def JM_choice_options(annot): ...
def JM_clear_pixmap_rect_with_value(dest, value, b): ...
def JM_color_FromSequence(color): ...
def JM_color_count(pm, clip): ...
def JM_compress_buffer(inbuffer): ...
def JM_copy_rectangle(page, area): ...
def JM_convert_to_pdf(doc, fp, tp, rotate): ...
def JM_create_widget(doc, page, type, fieldname): ...
def JM_cropbox(page_obj): ...
def JM_cropbox_size(page_obj): ...
def JM_derotate_page_matrix(page): ...
def JM_embed_file(pdf, buf, filename, ufilename, desc, compress): ...
def JM_embedded_clean(pdf) -> None: ...
def JM_EscapeStrFromBuffer(buff): ...
def JM_ensure_identity(pdf) -> None: ...
def JM_ensure_ocproperties(pdf): ...
def JM_expand_fname(name): ...
def JM_field_type_text(wtype): ...
def JM_fill_pixmap_rect_with_color(dest, col, b): ...
def JM_find_annot_irt(annot): ...
def JM_font_ascender(font): ...
def JM_font_descender(font): ...
def JM_is_word_delimiter(ch, delimiters): ...
def JM_is_rtl_char(ch): ...
def JM_font_name(font): ...
def JM_gather_fonts(pdf, dict_, fontlist, stream_xref): ...
def JM_gather_forms(doc, dict_: mupdf.PdfObj, imagelist, stream_xref: int): ...
def JM_gather_images(doc: mupdf.PdfDocument, dict_: mupdf.PdfObj, imagelist, stream_xref: int): ...
def JM_get_annot_by_xref(page, xref): ...
def JM_get_annot_by_name(page, name): ...
def JM_get_annot_id_list(page): ...
def JM_get_annot_xref_list(page_obj): ...
def JM_get_annot_xref_list2(page): ...
def JM_get_border_style(style): ...
def JM_get_font(fontname, fontfile, fontbuffer, script, lang, ordering, is_bold, is_italic, is_serif, embed): ...
def JM_get_fontbuffer(doc, xref): ...
def JM_get_resource_properties(ref): ...
def JM_get_widget_by_xref(page, xref): ...
def JM_get_widget_properties(annot, Widget): ...
def JM_get_fontextension(doc, xref): ...
def JM_get_ocg_arrays_imp(arr): ...
def JM_get_ocg_arrays(conf): ...
def JM_get_page_labels(liste, nums) -> None: ...
def JM_get_script(key): ...
def JM_have_operation(pdf): ...
def JM_image_extension(type_): ...

g_img_info: Incomplete

def JM_image_filter(opaque, ctm, name, image) -> None: ...
def JM_image_profile(imagedata, keep_image): ...
def JM_image_reporter(page): ...
def JM_fitz_config(): ...
def JM_insert_contents(pdf, pageref, newcont, overlay): ...
def JM_insert_font(pdf, bfname, fontfile, fontbuffer, set_simple, idx, wmode, serif, encoding, ordering): ...
def JM_irect_from_py(r): ...
def JM_listbox_value(annot): ...
def JM_make_annot_DA(annot, ncol, col, fontname, fontsize) -> None: ...
def JM_make_spanlist(line_dict, line, raw, buff, tp_rect): ...
def JM_make_image_block(block, block_dict) -> None: ...
def JM_make_text_block(block, block_dict, raw, buff, tp_rect): ...
def JM_make_textpage_dict(tp, page_dict, raw): ...
def JM_matrix_from_py(m): ...
def JM_mediabox(page_obj): ...
def JM_merge_range(doc_des, doc_src, spage, epage, apage, rotate, links, annots, show_progress, graft_map): ...
def JM_merge_resources(page, temp_res): ...
def JM_mupdf_warning(text) -> None: ...
def JM_mupdf_error(text) -> None: ...
def JM_new_bbox_device(rc, inc_layers): ...
def JM_new_buffer_from_stext_page(page): ...
def JM_new_javascript(pdf, value): ...
def JM_new_output_fileptr(bio): ...
def JM_norm_rotation(rotate): ...
def JM_object_to_buffer(what, compress, ascii): ...
def JM_outline_xrefs(obj, xrefs): ...
def JM_page_rotation(page): ...
def JM_pdf_obj_from_str(doc, src): ...
def JM_pixmap_from_display_list(list_, ctm, cs, alpha, clip, seps): ...
def JM_point_from_py(p): ...
def JM_print_stext_page_as_text(res, page): ...
def JM_put_script(annot_obj, key1, key2, value) -> None: ...
def JM_py_from_irect(r): ...
def JM_py_from_matrix(m): ...
def JM_py_from_point(p): ...
def JM_py_from_quad(q): ...
def JM_py_from_rect(r): ...
def JM_quad_from_py(r): ...
def JM_read_contents(pageref): ...
def JM_rect_from_py(r): ...
def JM_rects_overlap(a, b): ...
def JM_refresh_links(page) -> None: ...
def JM_rotate_page_matrix(page): ...
def JM_search_stext_page(page, needle): ...
def JM_scan_resources(pdf, rsrc, liste, what, stream_xref, tracer) -> None: ...
def JM_set_choice_options(annot, liste) -> None: ...
def JM_set_field_type(doc, obj, type) -> None: ...
def JM_set_object_value(obj, key, value): ...
def JM_set_ocg_arrays(conf, basestate, on, off, rbgroups, locked) -> None: ...
def JM_set_ocg_arrays_imp(arr, list_) -> None: ...
def JM_set_resource_property(ref, name, xref) -> None: ...
def JM_set_widget_properties(annot, Widget): ...
def JM_show_string_cs(text, user_font, trm, s, wmode, bidi_level, markup_dir, language): ...
def JM_UnicodeFromBuffer(buff): ...
def message_warning(text) -> None: ...
def JM_update_stream(doc, obj, buffer_, compress) -> None: ...
def JM_xobject_from_page(pdfout, fsrcpage, xref, gmap): ...
def PySequence_Check(s): ...
def PySequence_Size(s): ...

MSG_BAD_ANNOT_TYPE: str
MSG_BAD_APN: str
MSG_BAD_ARG_INK_ANNOT: str
MSG_BAD_ARG_POINTS: str
MSG_BAD_BUFFER: str
MSG_BAD_COLOR_SEQ: str
MSG_BAD_DOCUMENT: str
MSG_BAD_FILETYPE: str
MSG_BAD_LOCATION: str
MSG_BAD_OC_CONFIG: str
MSG_BAD_OC_LAYER: str
MSG_BAD_OC_REF: str
MSG_BAD_PAGEID: str
MSG_BAD_PAGENO: str
MSG_BAD_PDFROOT: str
MSG_BAD_RECT: str
MSG_BAD_TEXT: str
MSG_BAD_XREF: str
MSG_COLOR_COUNT_FAILED: str
MSG_FILE_OR_BUFFER: str
MSG_FONT_FAILED: str
MSG_IS_NO_ANNOT: str
MSG_IS_NO_IMAGE: str
MSG_IS_NO_PDF: str
MSG_IS_NO_DICT: str
MSG_PIX_NOALPHA: str
MSG_PIXEL_OUTSIDE: str
JM_Exc_FileDataError: str
PyExc_ValueError: str

def RAISEPY(msg, exc) -> None: ...
def PyUnicode_DecodeRawUnicodeEscape(s, errors: str = 'strict'): ...
def CheckColor(c: OptSeq): ...
def CheckFont(page: Page, fontname: str) -> tuple: ...
def CheckFontInfo(doc: Document, xref: int) -> list: ...
def CheckMarkerArg(quads: typing.Any) -> tuple: ...
def CheckMorph(o: typing.Any) -> bool: ...
def CheckParent(o: typing.Any): ...
def CheckQuad(q: typing.Any) -> bool: ...
def CheckRect(r: typing.Any) -> bool: ...
def ColorCode(c: list | tuple | float | None, f: str) -> str: ...
def Page__add_text_marker(self, quads, annot_type): ...
def PDF_NAME(x): ...
def UpdateFontInfo(doc: Document, info: typing.Sequence): ...
def args_match(args, *types): ...
def calc_image_matrix(width, height, tr, rotate, keep): ...
def detect_super_script(line, ch): ...
def dir_str(x): ...
def getTJstr(text: str, glyphs: list | tuple | None, simple: bool, ordering: int) -> str: ...
def get_pdf_str(s: str) -> str: ...
def get_tessdata(tessdata: Incomplete | None = None): ...
def css_for_pymupdf_font(fontcode: str, *, CSS: OptStr = None, archive: AnyType = None, name: OptStr = None) -> str: ...
def get_text_length(text: str, fontname: str = 'helv', fontsize: float = 11, encoding: int = 0) -> float: ...
def image_profile(img: typing.ByteString) -> dict: ...
def jm_append_merge(dev): ...
def jm_bbox_add_rect(dev, ctx, rect, code) -> None: ...
def jm_bbox_fill_image(dev, ctx, image, ctm, alpha, color_params) -> None: ...
def jm_bbox_fill_image_mask(dev, ctx, image, ctm, colorspace, color, alpha, color_params) -> None: ...
def jm_bbox_fill_path(dev, ctx, path, even_odd, ctm, colorspace, color, alpha, color_params) -> None: ...
def jm_bbox_fill_shade(dev, ctx, shade, ctm, alpha, color_params) -> None: ...
def jm_bbox_stroke_text(dev, ctx, text, stroke, ctm, *args) -> None: ...
def jm_bbox_fill_text(dev, ctx, text, ctm, *args) -> None: ...
def jm_bbox_ignore_text(dev, ctx, text, ctm) -> None: ...
def jm_bbox_stroke_path(dev, ctx, path, stroke, ctm, colorspace, color, alpha, color_params) -> None: ...
def jm_checkquad(dev): ...
def jm_checkrect(dev): ...
def jm_trace_text(dev, text, type_, ctm, colorspace, color, alpha, seqno) -> None: ...
def jm_trace_text_span(dev, span, type_, ctm, colorspace, color, alpha, seqno) -> None: ...
def jm_lineart_color(colorspace, color): ...
def jm_lineart_drop_device(dev, ctx) -> None: ...
def jm_lineart_fill_path(dev, ctx, path, even_odd, ctm, colorspace, color, alpha, color_params) -> None: ...
def jm_lineart_fill_text(dev, ctx, text, ctm, colorspace, color, alpha, color_params) -> None: ...
def jm_lineart_ignore_text(dev, text, ctm) -> None: ...

class Walker(mupdf.FzPathWalker2):
    dev: Incomplete
    def __init__(self, dev) -> None: ...
    def closepath(self, ctx) -> None: ...
    def curveto(self, ctx, x1, y1, x2, y2, x3, y3) -> None: ...
    def lineto(self, ctx, x, y) -> None: ...
    def moveto(self, ctx, x, y) -> None: ...

def jm_lineart_path(dev, ctx, path) -> None: ...
def jm_lineart_stroke_path(dev, ctx, path, stroke, ctm, colorspace, color, alpha, color_params) -> None: ...
def jm_lineart_clip_path(dev, ctx, path, even_odd, ctm, scissor) -> None: ...
def jm_lineart_clip_stroke_path(dev, ctx, path, stroke, ctm, scissor) -> None: ...
def jm_lineart_clip_stroke_text(dev, ctx, text, stroke, ctm, scissor) -> None: ...
def jm_lineart_clip_text(dev, ctx, text, ctm, scissor) -> None: ...
def jm_lineart_clip_image_mask(dev, ctx, image, ctm, scissor) -> None: ...
def jm_lineart_pop_clip(dev, ctx) -> None: ...
def jm_lineart_begin_layer(dev, ctx, name) -> None: ...
def jm_lineart_end_layer(dev, ctx) -> None: ...
def jm_lineart_begin_group(dev, ctx, bbox, cs, isolated, knockout, blendmode, alpha) -> None: ...
def jm_lineart_end_group(dev, ctx) -> None: ...
def jm_lineart_stroke_text(dev, ctx, text, stroke, ctm, colorspace, color, alpha, color_params) -> None: ...
def jm_dev_linewidth(dev, ctx, path, stroke, matrix, colorspace, color, alpha, color_params) -> None: ...
def jm_increase_seqno(dev, ctx, *vargs) -> None: ...
def planish_line(p1: point_like, p2: point_like) -> Matrix: ...

class JM_image_reporter_Filter(mupdf.PdfFilterOptions2):
    def __init__(self) -> None: ...
    def image_filter(self, ctx, ctm, name, image): ...

class JM_new_bbox_device_Device(mupdf.FzDevice2):
    result: Incomplete
    layers: Incomplete
    def __init__(self, result, layers) -> None: ...
    begin_layer = jm_lineart_begin_layer
    end_layer = jm_lineart_end_layer
    fill_path = jm_bbox_fill_path
    stroke_path = jm_bbox_stroke_path
    fill_text = jm_bbox_fill_text
    stroke_text = jm_bbox_stroke_text
    ignore_text = jm_bbox_ignore_text
    fill_shade = jm_bbox_fill_shade
    fill_image = jm_bbox_fill_image
    fill_image_mask = jm_bbox_fill_image_mask

class JM_new_output_fileptr_Output(mupdf.FzOutput2):
    bio: Incomplete
    def __init__(self, bio) -> None: ...
    def seek(self, ctx, offset, whence): ...
    def tell(self, ctx): ...
    def truncate(self, ctx): ...
    def write(self, ctx, data_raw, data_length): ...

def compute_scissor(dev): ...

class JM_new_lineart_device_Device(mupdf.FzDevice2):
    out: Incomplete
    seqno: int
    depth: int
    clips: Incomplete
    method: Incomplete
    scissors: Incomplete
    layer_name: str
    pathrect: Incomplete
    linewidth: int
    ptm: Incomplete
    ctm: Incomplete
    rot: Incomplete
    lastpoint: Incomplete
    firstpoint: Incomplete
    havemove: int
    pathfactor: int
    linecount: int
    path_type: int
    def __init__(self, out, clips, method) -> None: ...
    fill_path = jm_lineart_fill_path
    stroke_path = jm_lineart_stroke_path
    clip_image_mask = jm_lineart_clip_image_mask
    clip_path = jm_lineart_clip_path
    clip_stroke_path = jm_lineart_clip_stroke_path
    clip_text = jm_lineart_clip_text
    clip_stroke_text = jm_lineart_clip_stroke_text
    fill_text = jm_increase_seqno
    stroke_text = jm_increase_seqno
    ignore_text = jm_increase_seqno
    fill_shade = jm_increase_seqno
    fill_image = jm_increase_seqno
    fill_image_mask = jm_increase_seqno
    pop_clip = jm_lineart_pop_clip
    begin_group = jm_lineart_begin_group
    end_group = jm_lineart_end_group
    begin_layer = jm_lineart_begin_layer
    end_layer = jm_lineart_end_layer

class JM_new_texttrace_device(mupdf.FzDevice2):
    out: Incomplete
    seqno: int
    depth: int
    clips: int
    method: Incomplete
    pathdict: Incomplete
    scissors: Incomplete
    linewidth: int
    ptm: Incomplete
    ctm: Incomplete
    rot: Incomplete
    lastpoint: Incomplete
    pathrect: Incomplete
    pathfactor: int
    linecount: int
    path_type: int
    layer_name: str
    def __init__(self, out) -> None: ...
    fill_path = jm_increase_seqno
    stroke_path = jm_dev_linewidth
    fill_text = jm_lineart_fill_text
    stroke_text = jm_lineart_stroke_text
    ignore_text = jm_lineart_ignore_text
    fill_shade = jm_increase_seqno
    fill_image = jm_increase_seqno
    fill_image_mask = jm_increase_seqno
    begin_layer = jm_lineart_begin_layer
    end_layer = jm_lineart_end_layer

def ConversionHeader(i: str, filename: OptStr = 'unknown'): ...
def ConversionTrailer(i: str): ...
def annot_preprocess(page: Page) -> int: ...
def annot_postprocess(page: Page, annot: Annot) -> None: ...
def canon(c): ...
def chartocanon(s): ...
def dest_is_valid(o, page_count, page_object_nums, names_list): ...
def dest_is_valid_page(obj, page_object_nums, pagecount): ...
def find_string(s, needle): ...
def get_pdf_now() -> str: ...

class ElementPosition:
    def __init__(self) -> None: ...

def make_story_elpos(): ...
def get_highlight_selection(page, start: point_like = None, stop: point_like = None, clip: rect_like = None) -> list: ...
def glyph_name_to_unicode(name: str) -> int: ...
def hdist(dir, a, b): ...
def make_table(rect: rect_like = (0, 0, 1, 1), cols: int = 1, rows: int = 1) -> list: ...
def util_ensure_widget_calc(annot) -> None: ...
def util_make_rect(*args, p0: Incomplete | None = None, p1: Incomplete | None = None, x0: Incomplete | None = None, y0: Incomplete | None = None, x1: Incomplete | None = None, y1: Incomplete | None = None): ...
def util_make_irect(*args, p0: Incomplete | None = None, p1: Incomplete | None = None, x0: Incomplete | None = None, y0: Incomplete | None = None, x1: Incomplete | None = None, y1: Incomplete | None = None): ...
def util_round_rect(rect): ...
def util_transform_rect(rect, matrix): ...
def util_intersect_rect(r1, r2): ...
def util_is_point_in_rect(p, r): ...
def util_include_point_in_rect(r, p): ...
def util_point_in_quad(P, Q): ...
def util_transform_point(point, matrix): ...
def util_union_rect(r1, r2): ...
def util_concat_matrix(m1, m2): ...
def util_invert_matrix(matrix): ...
def util_measure_string(text, fontname, fontsize, encoding): ...
def util_sine_between(C, P, Q): ...
def util_hor_matrix(C, P): ...
def match_string(h0, n0): ...
def on_highlight_char(hits, line, ch) -> None: ...
def page_merge(doc_des, doc_src, page_from, page_to, rotate, links, copy_annots, graft_map): ...
def paper_rect(s: str) -> Rect: ...
def paper_size(s: str) -> tuple: ...
def paper_sizes(): ...
def pdf_lookup_page_loc(doc, needle): ...
def pdfobj_string(o, prefix: str = ''): ...
def repair_mono_font(page: Page, font: Font) -> None: ...
def sRGB_to_pdf(srgb: int) -> tuple: ...
def sRGB_to_rgb(srgb: int) -> tuple: ...
def string_in_names_list(p, names_list): ...
def strip_outline(doc, outlines, page_count, page_object_nums, names_list): ...
def strip_outlines(doc, outlines, page_count, page_object_nums, names_list): ...

trace_device_FILL_PATH: int
trace_device_STROKE_PATH: int
trace_device_CLIP_PATH: int
trace_device_CLIP_STROKE_PATH: int

def unicode_to_glyph_name(ch: int) -> str: ...
def vdist(dir, a, b): ...
def apply_pages(path, pagefn, *, pagefn_args=(), pagefn_kwargs=..., initfn: Incomplete | None = None, initfn_args=(), initfn_kwargs=..., pages: Incomplete | None = None, method: str = 'single', concurrency: Incomplete | None = None, _stats: bool = False): ...
def get_text(path, *, pages: Incomplete | None = None, method: str = 'single', concurrency: Incomplete | None = None, option: str = 'text', clip: Incomplete | None = None, flags: Incomplete | None = None, textpage: Incomplete | None = None, sort: bool = False, delimiters: Incomplete | None = None, _stats: bool = False): ...

class TOOLS:
    @staticmethod
    def gen_id(): ...
    @staticmethod
    def glyph_cache_empty() -> None: ...
    @staticmethod
    def image_profile(stream, keep_image: int = 0): ...
    @staticmethod
    def mupdf_display_errors(on: Incomplete | None = None): ...
    @staticmethod
    def mupdf_display_warnings(on: Incomplete | None = None): ...
    @staticmethod
    def mupdf_version(): ...
    @staticmethod
    def mupdf_warnings(reset: int = 1): ...
    @staticmethod
    def reset_mupdf_warnings() -> None: ...
    @staticmethod
    def set_aa_level(level) -> None: ...
    @staticmethod
    def set_annot_stem(stem: Incomplete | None = None): ...
    @staticmethod
    def set_font_width(doc, xref, width): ...
    @staticmethod
    def set_graphics_min_line_width(min_line_width) -> None: ...
    @staticmethod
    def set_icc(on: int = 0) -> None: ...
    @staticmethod
    def set_low_memory(on: Incomplete | None = None): ...
    @staticmethod
    def set_small_glyph_heights(on: Incomplete | None = None): ...
    @staticmethod
    def set_subset_fontnames(on: Incomplete | None = None): ...
    @staticmethod
    def show_aa_level(): ...
    @staticmethod
    def store_maxsize() -> None: ...
    @staticmethod
    def store_shrink(percent): ...
    @staticmethod
    def store_size() -> None: ...
    @staticmethod
    def unset_quad_corrections(on: Incomplete | None = None): ...
    JM_annot_id_stem: str
    fitz_config: Incomplete

pdfcolor: Incomplete

def colors_pdf_dict(): ...
def colors_wx_list(): ...

recover_bbox_quad: Incomplete
recover_char_quad: Incomplete
recover_line_quad: Incomplete
recover_quad: Incomplete
recover_span_quad: Incomplete

class FitzDeprecation(DeprecationWarning): ...

def restore_aliases(): ...
__version__ = VersionBind
__doc__: Incomplete
