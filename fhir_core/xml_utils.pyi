import typing
from collections import deque
from pathlib import Path
from types import ModuleType

from _typeshed import Incomplete
from lxml import etree
from lxml.etree import QName
from pydantic.fields import FieldInfo

from .fhirabstractmodel import FHIRAbstractModel

__all__ = ["xml_dumps", "xml_loads"]

StrBytes = str | bytes
StrNone = str | None
StrBytesNone = str | bytes | None
DictStr = dict[str, str]
DictStrBytes = dict[str, StrBytes]
DictStrNoneKey = dict[str | None, str]
DictStrBytesNoneKey = dict[StrNone, StrBytes]
TupleStrKeyVal = tuple[str, StrBytes]

class SimpleNodeStorage:
    node: Node
    __storage__: deque
    def __init__(self, node) -> None: ...
    def __iter__(self): ...
    def __getitem__(self, index): ...
    def __len__(self) -> int: ...
    def append(self, item) -> None: ...
    def extend(self, items) -> None: ...
    def as_list(self): ...

class NodeContainer(SimpleNodeStorage):
    def __init__(self, node) -> None: ...
    def append(self, item) -> None: ...
    def extend(self, items) -> None: ...

class AttributeContainer(SimpleNodeStorage):
    def __init__(self, node: Node) -> None: ...
    def append(self, item: Attribute): ...
    def extend(self, items: list["Attribute"]): ...

class NamespaceContainer(SimpleNodeStorage):
    def __init__(self, node: Node) -> None: ...
    def append(self, item: Namespace): ...
    def extend(self, items: list["Namespace"]): ...

class CommentContainer(SimpleNodeStorage):
    def __init__(self, node: Node) -> None: ...
    def append(self, item: Comment): ...
    def extend(self, items: list["Comment"]): ...

class AttributeValue:
    raw: str
    quote: Incomplete
    def __init__(self, raw: StrBytes, quote: bool = False) -> None: ...
    def to_xml(self) -> str: ...
    def __eq__(self, other): ...

class Attribute:
    name: str | QName
    value: StrBytes | AttributeValue | None
    def __init__(self, name: str | QName, value: StrBytes | AttributeValue | None) -> None: ...
    def to_xml(self) -> tuple[str, StrNone]: ...
    def __eq__(self, other): ...

class Namespace:
    name: StrNone
    location: Incomplete
    def __init__(self, name: StrNone, location: StrBytes) -> None: ...
    def to_xml(self): ...
    def __eq__(self, other): ...

class Comment:
    def __init__(self, comment: StrBytes) -> None: ...
    def to_xml(self) -> etree._Comment: ...
    def to_string(self) -> str: ...
    @classmethod
    def from_element(cls, element: etree._Comment) -> Comment: ...

class Node:
    name: Incomplete
    attributes: Incomplete
    namespaces: Incomplete
    comments: Incomplete
    parent: Incomplete
    children: Incomplete
    def __init__(
        self,
        name: str | QName,
        *,
        value: StrBytes | None = None,
        text: StrBytes | Node | None = None,
        attributes: list[Attribute] | None = None,
        namespaces: list[Namespace] | None = None,
        comments: list[Comment] | None = None,
        parent: Node | None = None,
        children: list["Node"] | None = None,
    ) -> None: ...
    def rename(self, new_name) -> None: ...
    def add_namespace(self, ns: Namespace | StrNone, location: StrBytes | None = None): ...
    def add_attribute(self, attr: str | Attribute, value: StrBytes | None = None): ...
    @property
    def text(self): ...
    @text.setter
    def text(self, val) -> None: ...
    @property
    def value(self): ...
    @value.setter
    def value(self, val) -> None: ...
    def set_text(self, value) -> None: ...
    def add_text(self, value, prefix: str = "", suffix: str = "") -> None: ...
    @classmethod
    def create(
        cls,
        name,
        *,
        value: str | bytes | None = None,
        text: str | bytes | Node | None = None,
        attrs: DictStrBytes | list[Attribute | tuple[str, StrBytes]] | None = None,
        namespaces: DictStrBytesNoneKey | list[Namespace | tuple[StrNone, StrBytes]] | None = None,
    ): ...
    @staticmethod
    def clean_tag(element: etree._Element) -> str: ...
    @classmethod
    def from_element(
        cls,
        element: etree._Element,
        parent: Node | None = None,
        exists_ns: list[Namespace] | None = None,
        comments: list[Comment] | None = None,
    ): ...
    @staticmethod
    def inject_comments(node: Node, comments: str | list[str]) -> None: ...
    @staticmethod
    def add_fhir_element(
        parent: Node,
        field: FieldInfo,
        value: typing.Any,
        ext: Incomplete | None = None,
        ext_field: Incomplete | None = None,
    ): ...
    @classmethod
    def from_fhir_obj(cls, model: FHIRAbstractModel): ...
    def to_xml(self, parent: etree._Element = None): ...
    def normalize_attributes(self): ...
    def normalize_namespaces(self): ...
    @classmethod
    def validate(
        cls,
        element: Node | etree._Element | bytes,
        xsd_file: Path | None = None,
        xmlparser: etree.XMLParser | None = None,
    ): ...
    def to_string(
        self,
        pretty_print: bool = False,
        xml_declaration: bool = True,
        with_comments: bool = True,
        strip_text: bool = False,
    ): ...
    @staticmethod
    def get_fhir_value(obj: Node | etree._Element, field: FieldInfo, root_mod: ModuleType) -> typing.Any: ...
    def to_fhir(self, klass: type["FHIRAbstractModel"], root_mod: ModuleType = None) -> FHIRAbstractModel: ...

def xml_dumps(
    model: FHIRAbstractModel,
    *,
    pretty_print: bool = False,
    xml_declaration: bool = True,
    with_comments: bool = True,
    strip_text: bool = False,
): ...
def xml_loads(cls, b: str | bytes | bytearray, xmlparser: etree.XMLParser = None) -> FHIRAbstractModel: ...
